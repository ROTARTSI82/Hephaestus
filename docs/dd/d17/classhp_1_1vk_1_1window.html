<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Hephaestus: hp::vk::window Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Hephaestus
   &#160;<span id="projectnumber">0.0.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d6/d7a/namespacehp.html">hp</a></li><li class="navelem"><a class="el" href="../../da/d74/namespacehp_1_1vk.html">vk</a></li><li class="navelem"><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html">window</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">hp::vk::window Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Describes a vulkan window. Is used as a base for all operations.  
 <a href="../../dd/d17/classhp_1_1vk_1_1window.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d2/d5a/window_8hpp_source.html">window.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2644434374ae6f8b89831c7580e84485"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#a2644434374ae6f8b89831c7580e84485">window</a> ()=default</td></tr>
<tr class="memdesc:a2644434374ae6f8b89831c7580e84485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard default constructor.  <a href="../../dd/d17/classhp_1_1vk_1_1window.html#a2644434374ae6f8b89831c7580e84485">More...</a><br /></td></tr>
<tr class="separator:a2644434374ae6f8b89831c7580e84485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f843075e00dd94c871a7123e8832ec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#a66f843075e00dd94c871a7123e8832ec">window</a> (int width, int height, const char *app_name, uint32_t version)</td></tr>
<tr class="memdesc:a66f843075e00dd94c871a7123e8832ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Window constructor.  <a href="../../dd/d17/classhp_1_1vk_1_1window.html#a66f843075e00dd94c871a7123e8832ec">More...</a><br /></td></tr>
<tr class="separator:a66f843075e00dd94c871a7123e8832ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6cf6c258a30ce482fc6d5867b53cca4"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#ae6cf6c258a30ce482fc6d5867b53cca4">~window</a> ()</td></tr>
<tr class="memdesc:ae6cf6c258a30ce482fc6d5867b53cca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard virtual destructor.  <a href="../../dd/d17/classhp_1_1vk_1_1window.html#ae6cf6c258a30ce482fc6d5867b53cca4">More...</a><br /></td></tr>
<tr class="separator:ae6cf6c258a30ce482fc6d5867b53cca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662c8ef349c9a583355590e2d217238a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#a662c8ef349c9a583355590e2d217238a">window</a> (const <a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html">window</a> &amp;other)=delete</td></tr>
<tr class="memdesc:a662c8ef349c9a583355590e2d217238a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted copy constructor. Use the move constructor instead.  <a href="../../dd/d17/classhp_1_1vk_1_1window.html#a662c8ef349c9a583355590e2d217238a">More...</a><br /></td></tr>
<tr class="separator:a662c8ef349c9a583355590e2d217238a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10920ba0b45232900147bff04455df23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html">window</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#a10920ba0b45232900147bff04455df23">operator=</a> (const <a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html">window</a> &amp;rhs)=delete</td></tr>
<tr class="memdesc:a10920ba0b45232900147bff04455df23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted copy assignment operator. Use the move assignment operator instead.  <a href="../../dd/d17/classhp_1_1vk_1_1window.html#a10920ba0b45232900147bff04455df23">More...</a><br /></td></tr>
<tr class="separator:a10920ba0b45232900147bff04455df23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33053d857eb24d1752ba5d53c4e7d79"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#ae33053d857eb24d1752ba5d53c4e7d79">window</a> (<a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html">window</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:ae33053d857eb24d1752ba5d53c4e7d79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard copy constructor.  <a href="../../dd/d17/classhp_1_1vk_1_1window.html#ae33053d857eb24d1752ba5d53c4e7d79">More...</a><br /></td></tr>
<tr class="separator:ae33053d857eb24d1752ba5d53c4e7d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4d21756ed28640247697cde8714e022"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html">window</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#ae4d21756ed28640247697cde8714e022">operator=</a> (<a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html">window</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:ae4d21756ed28640247697cde8714e022"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard move assignment operator.  <a href="../../dd/d17/classhp_1_1vk_1_1window.html#ae4d21756ed28640247697cde8714e022">More...</a><br /></td></tr>
<tr class="separator:ae4d21756ed28640247697cde8714e022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fbc1a441b349b504876a368913edc0f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#a3fbc1a441b349b504876a368913edc0f">ext_supported</a> (const char *ext)</td></tr>
<tr class="memdesc:a3fbc1a441b349b504876a368913edc0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query if an extension is supported by the current instance.  <a href="../../dd/d17/classhp_1_1vk_1_1window.html#a3fbc1a441b349b504876a368913edc0f">More...</a><br /></td></tr>
<tr class="separator:a3fbc1a441b349b504876a368913edc0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7021dcc20c2920b0a10daf40494ae61"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#af7021dcc20c2920b0a10daf40494ae61">dev_ext_supported</a> (const char *ext)</td></tr>
<tr class="memdesc:af7021dcc20c2920b0a10daf40494ae61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query if an extension is supported by the current physical device.  <a href="../../dd/d17/classhp_1_1vk_1_1window.html#af7021dcc20c2920b0a10daf40494ae61">More...</a><br /></td></tr>
<tr class="separator:af7021dcc20c2920b0a10daf40494ae61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc875261858f4bdb4815963733327e5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#a3bc875261858f4bdb4815963733327e5">layer_supported</a> (const char *lay)</td></tr>
<tr class="memdesc:a3bc875261858f4bdb4815963733327e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a validation layer is supported by the current instance.  <a href="../../dd/d17/classhp_1_1vk_1_1window.html#a3bc875261858f4bdb4815963733327e5">More...</a><br /></td></tr>
<tr class="separator:a3bc875261858f4bdb4815963733327e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba36c9e984ffc59fd802bf7973960ce1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#aba36c9e984ffc59fd802bf7973960ce1">should_close</a> ()</td></tr>
<tr class="memdesc:aba36c9e984ffc59fd802bf7973960ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Poll if this window should be closed (ie. The user closed it)  <a href="../../dd/d17/classhp_1_1vk_1_1window.html#aba36c9e984ffc59fd802bf7973960ce1">More...</a><br /></td></tr>
<tr class="separator:aba36c9e984ffc59fd802bf7973960ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056dc1c6e863cbc75da8b18b8f468a8f"><td class="memItemLeft" align="right" valign="top">inline ::vk::Extent2D&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#a056dc1c6e863cbc75da8b18b8f468a8f">get_dims</a> ()</td></tr>
<tr class="memdesc:a056dc1c6e863cbc75da8b18b8f468a8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current size of the window (in pixels).  <a href="../../dd/d17/classhp_1_1vk_1_1window.html#a056dc1c6e863cbc75da8b18b8f468a8f">More...</a><br /></td></tr>
<tr class="separator:a056dc1c6e863cbc75da8b18b8f468a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa72a176c0c12f8a19a912e22872bcd0b"><td class="memItemLeft" align="right" valign="top">std::pair&lt;::vk::Fence, ::vk::CommandBuffer &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#aa72a176c0c12f8a19a912e22872bcd0b">copy_buffer</a> (<a class="el" href="../../d6/d0a/classhp_1_1vk_1_1generic__buffer.html">generic_buffer</a> *source, <a class="el" href="../../d6/d0a/classhp_1_1vk_1_1generic__buffer.html">generic_buffer</a> *dest, bool wait=true, size_t src_offset=0, size_t dest_offset=0, size_t size=0)</td></tr>
<tr class="memdesc:aa72a176c0c12f8a19a912e22872bcd0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data from one buffer to another.  <a href="../../dd/d17/classhp_1_1vk_1_1window.html#aa72a176c0c12f8a19a912e22872bcd0b">More...</a><br /></td></tr>
<tr class="separator:aa72a176c0c12f8a19a912e22872bcd0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17536da75810d265a3f480d2ad37a2b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#a17536da75810d265a3f480d2ad37a2b1">write_buffer</a> (<a class="el" href="../../d6/d0a/classhp_1_1vk_1_1generic__buffer.html">generic_buffer</a> *buf, const void *data, size_t offset=0, size_t size=0)</td></tr>
<tr class="memdesc:a17536da75810d265a3f480d2ad37a2b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to a buffer with <code>eHostCoherent</code> and <code>eHostVisible</code>.  <a href="../../dd/d17/classhp_1_1vk_1_1window.html#a17536da75810d265a3f480d2ad37a2b1">More...</a><br /></td></tr>
<tr class="separator:a17536da75810d265a3f480d2ad37a2b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2ec279762d0dc85f2382dd4337ee1e"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#a4a2ec279762d0dc85f2382dd4337ee1e">start_write</a> (<a class="el" href="../../d6/d0a/classhp_1_1vk_1_1generic__buffer.html">generic_buffer</a> *buf)</td></tr>
<tr class="memdesc:a4a2ec279762d0dc85f2382dd4337ee1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map a buffer so it is ready for writing.  <a href="../../dd/d17/classhp_1_1vk_1_1window.html#a4a2ec279762d0dc85f2382dd4337ee1e">More...</a><br /></td></tr>
<tr class="separator:a4a2ec279762d0dc85f2382dd4337ee1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f4a25b2c0e0d68389d8d286404fbebc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#a3f4a25b2c0e0d68389d8d286404fbebc">write_buffer</a> (uint8_t *dest, <a class="el" href="../../d6/d0a/classhp_1_1vk_1_1generic__buffer.html">generic_buffer</a> *buf, const void *src, size_t offset=0, size_t size=0)</td></tr>
<tr class="memdesc:a3f4a25b2c0e0d68389d8d286404fbebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to a buffer with <code>eHostCoherent</code> and <code>eHostVisible</code>.  <a href="../../dd/d17/classhp_1_1vk_1_1window.html#a3f4a25b2c0e0d68389d8d286404fbebc">More...</a><br /></td></tr>
<tr class="separator:a3f4a25b2c0e0d68389d8d286404fbebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a650ae8a55d1b43a4e948217c38abd388"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#a650ae8a55d1b43a4e948217c38abd388">stop_write</a> (<a class="el" href="../../d6/d0a/classhp_1_1vk_1_1generic__buffer.html">generic_buffer</a> *buf)</td></tr>
<tr class="memdesc:a650ae8a55d1b43a4e948217c38abd388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmap a buffer so it is ready for reading and use.  <a href="../../dd/d17/classhp_1_1vk_1_1window.html#a650ae8a55d1b43a4e948217c38abd388">More...</a><br /></td></tr>
<tr class="separator:a650ae8a55d1b43a4e948217c38abd388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a887c3c901c8e64840d36b65ceb989de4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#a887c3c901c8e64840d36b65ceb989de4">set_swap_recreate_callback</a> (void(*new_callback)(::vk::Extent2D))</td></tr>
<tr class="memdesc:a887c3c901c8e64840d36b65ceb989de4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the callback that is called whenever the swapchain needs to be recreated.  <a href="../../dd/d17/classhp_1_1vk_1_1window.html#a887c3c901c8e64840d36b65ceb989de4">More...</a><br /></td></tr>
<tr class="separator:a887c3c901c8e64840d36b65ceb989de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1717af3841efc5694069541010d42c35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#a1717af3841efc5694069541010d42c35">clear_recording</a> ()</td></tr>
<tr class="memdesc:a1717af3841efc5694069541010d42c35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the recording buffer.  <a href="../../dd/d17/classhp_1_1vk_1_1window.html#a1717af3841efc5694069541010d42c35">More...</a><br /></td></tr>
<tr class="separator:a1717af3841efc5694069541010d42c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf9acdf9dca93ec205add02b07debbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#accf9acdf9dca93ec205add02b07debbe">save_recording</a> ()</td></tr>
<tr class="memdesc:accf9acdf9dca93ec205add02b07debbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new command buffers according to the contents of the recording buffer.  <a href="../../dd/d17/classhp_1_1vk_1_1window.html#accf9acdf9dca93ec205add02b07debbe">More...</a><br /></td></tr>
<tr class="separator:accf9acdf9dca93ec205add02b07debbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bd0d8d5fa09d80bf61f1309bbbbe144"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#a7bd0d8d5fa09d80bf61f1309bbbbe144">rec_bind_shader</a> (<a class="el" href="../../d0/d92/classhp_1_1vk_1_1shader__program.html">shader_program</a> *shader)</td></tr>
<tr class="memdesc:a7bd0d8d5fa09d80bf61f1309bbbbe144"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a pipeline binding operation to the recording buffer.  <a href="../../dd/d17/classhp_1_1vk_1_1window.html#a7bd0d8d5fa09d80bf61f1309bbbbe144">More...</a><br /></td></tr>
<tr class="separator:a7bd0d8d5fa09d80bf61f1309bbbbe144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9803e6ae8daa92d634b277712c12cc24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#a9803e6ae8daa92d634b277712c12cc24">rec_set_viewport</a> (::vk::Viewport viewport)</td></tr>
<tr class="memdesc:a9803e6ae8daa92d634b277712c12cc24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record setting the viewport. Consult vulkan docs.  <a href="../../dd/d17/classhp_1_1vk_1_1window.html#a9803e6ae8daa92d634b277712c12cc24">More...</a><br /></td></tr>
<tr class="separator:a9803e6ae8daa92d634b277712c12cc24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedd05d260b2d9c0ed537b899b2a4d755"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#aedd05d260b2d9c0ed537b899b2a4d755">rec_set_scissor</a> (::vk::Rect2D scissor)</td></tr>
<tr class="memdesc:aedd05d260b2d9c0ed537b899b2a4d755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record setting the scissor. Consult vulkan docs.  <a href="../../dd/d17/classhp_1_1vk_1_1window.html#aedd05d260b2d9c0ed537b899b2a4d755">More...</a><br /></td></tr>
<tr class="separator:aedd05d260b2d9c0ed537b899b2a4d755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ffec5451f68d4a2eaa973310743717d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#a6ffec5451f68d4a2eaa973310743717d">rec_set_default_viewport</a> ()</td></tr>
<tr class="memdesc:a6ffec5451f68d4a2eaa973310743717d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record setting the default viewport, which covers the entire screen.  <a href="../../dd/d17/classhp_1_1vk_1_1window.html#a6ffec5451f68d4a2eaa973310743717d">More...</a><br /></td></tr>
<tr class="separator:a6ffec5451f68d4a2eaa973310743717d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a904e80624e2028229a320a674626abb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#a904e80624e2028229a320a674626abb5">rec_set_default_scissor</a> ()</td></tr>
<tr class="memdesc:a904e80624e2028229a320a674626abb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record setting the default scissor, which covers the entire screen.  <a href="../../dd/d17/classhp_1_1vk_1_1window.html#a904e80624e2028229a320a674626abb5">More...</a><br /></td></tr>
<tr class="separator:a904e80624e2028229a320a674626abb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1673d156a395348eb49f8ffb3af56bfe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#a1673d156a395348eb49f8ffb3af56bfe">rec_bind_vbo</a> (<a class="el" href="../../df/d19/structhp_1_1vk_1_1vertex__buffer.html">vertex_buffer</a> vbo)</td></tr>
<tr class="memdesc:a1673d156a395348eb49f8ffb3af56bfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record binding a vertex buffer.  <a href="../../dd/d17/classhp_1_1vk_1_1window.html#a1673d156a395348eb49f8ffb3af56bfe">More...</a><br /></td></tr>
<tr class="separator:a1673d156a395348eb49f8ffb3af56bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00141a7a44204dddc48ef529f41a0459"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#a00141a7a44204dddc48ef529f41a0459">rec_bind_index_buffer</a> (<a class="el" href="../../d2/d99/structhp_1_1vk_1_1index__buffer.html">index_buffer</a> ibo)</td></tr>
<tr class="memdesc:a00141a7a44204dddc48ef529f41a0459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record binding an index buffer.  <a href="../../dd/d17/classhp_1_1vk_1_1window.html#a00141a7a44204dddc48ef529f41a0459">More...</a><br /></td></tr>
<tr class="separator:a00141a7a44204dddc48ef529f41a0459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38bdd83da7bcc03e0337505f0a2a8829"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#a38bdd83da7bcc03e0337505f0a2a8829">rec_draw_indexed</a> (uint32_t num_indices)</td></tr>
<tr class="memdesc:a38bdd83da7bcc03e0337505f0a2a8829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record issuing a draw command using the index buffer.  <a href="../../dd/d17/classhp_1_1vk_1_1window.html#a38bdd83da7bcc03e0337505f0a2a8829">More...</a><br /></td></tr>
<tr class="separator:a38bdd83da7bcc03e0337505f0a2a8829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f7cf0a4354f54666976981b179b4294"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#a6f7cf0a4354f54666976981b179b4294">rec_draw</a> (unsigned num_verts)</td></tr>
<tr class="memdesc:a6f7cf0a4354f54666976981b179b4294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record issuing a standard draw command.  <a href="../../dd/d17/classhp_1_1vk_1_1window.html#a6f7cf0a4354f54666976981b179b4294">More...</a><br /></td></tr>
<tr class="separator:a6f7cf0a4354f54666976981b179b4294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ca9e8ae513e459b6fb0b6111b35624f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d92/classhp_1_1vk_1_1shader__program.html">shader_program</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#a5ca9e8ae513e459b6fb0b6111b35624f">new_shader_program</a> (const std::string &amp;fp, const char *metapath=&quot;/shader_metadat.txt&quot;)</td></tr>
<tr class="memdesc:a5ca9e8ae513e459b6fb0b6111b35624f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct and retrieve a new <code><a class="el" href="../../d0/d92/classhp_1_1vk_1_1shader__program.html" title="An abstraction of graphics pipelines (aka vk::Pipeline objects). See hp::vk::window::new_shader_progr...">hp::vk::shader_program</a></code>  <a href="../../dd/d17/classhp_1_1vk_1_1window.html#a5ca9e8ae513e459b6fb0b6111b35624f">More...</a><br /></td></tr>
<tr class="separator:a5ca9e8ae513e459b6fb0b6111b35624f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8065ba588e52c870c41e718d309ec78d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#a8065ba588e52c870c41e718d309ec78d">delete_shader_program</a> (<a class="el" href="../../d0/d92/classhp_1_1vk_1_1shader__program.html">shader_program</a> *sh)</td></tr>
<tr class="memdesc:a8065ba588e52c870c41e718d309ec78d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a <a class="el" href="../../d0/d92/classhp_1_1vk_1_1shader__program.html" title="An abstraction of graphics pipelines (aka vk::Pipeline objects). See hp::vk::window::new_shader_progr...">shader_program</a> associated with this window.  <a href="../../dd/d17/classhp_1_1vk_1_1window.html#a8065ba588e52c870c41e718d309ec78d">More...</a><br /></td></tr>
<tr class="separator:a8065ba588e52c870c41e718d309ec78d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5058be06596795644634e8a924897b3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#a5058be06596795644634e8a924897b3b">delete_cmd_buffers</a> (::vk::CommandBuffer *bufs, uint32_t num=1)</td></tr>
<tr class="memdesc:a5058be06596795644634e8a924897b3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy any command buffer associated with this window allocated to the current <code>cmd_pool</code>  <a href="../../dd/d17/classhp_1_1vk_1_1window.html#a5058be06596795644634e8a924897b3b">More...</a><br /></td></tr>
<tr class="separator:a5058be06596795644634e8a924897b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd6dabdc499807c314ea44a40727c6f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#abd6dabdc499807c314ea44a40727c6f2">wait_fences</a> (::vk::Fence *fences, uint32_t num=1, uint64_t timeout=UINT64_MAX)</td></tr>
<tr class="memdesc:abd6dabdc499807c314ea44a40727c6f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block until the fences provided are signaled.  <a href="../../dd/d17/classhp_1_1vk_1_1window.html#abd6dabdc499807c314ea44a40727c6f2">More...</a><br /></td></tr>
<tr class="separator:abd6dabdc499807c314ea44a40727c6f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8e50ae3bd4eb6d91deb2bc9bb06fb3"><td class="memItemLeft" align="right" valign="top">inline ::vk::Fence&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#aea8e50ae3bd4eb6d91deb2bc9bb06fb3">new_fence</a> ()</td></tr>
<tr class="memdesc:aea8e50ae3bd4eb6d91deb2bc9bb06fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct and retrieve a new vk::Fence. See vulkan documentation for more details.  <a href="../../dd/d17/classhp_1_1vk_1_1window.html#aea8e50ae3bd4eb6d91deb2bc9bb06fb3">More...</a><br /></td></tr>
<tr class="separator:aea8e50ae3bd4eb6d91deb2bc9bb06fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a249fbf64d20a1b873899d967149a10dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#a249fbf64d20a1b873899d967149a10dc">delete_fence</a> (::vk::Fence fence)</td></tr>
<tr class="memdesc:a249fbf64d20a1b873899d967149a10dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a fence associated with this window.  <a href="../../dd/d17/classhp_1_1vk_1_1window.html#a249fbf64d20a1b873899d967149a10dc">More...</a><br /></td></tr>
<tr class="separator:a249fbf64d20a1b873899d967149a10dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6415277ee06f658a46e3f2197f52d72d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d6/d0a/classhp_1_1vk_1_1generic__buffer.html">generic_buffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#a6415277ee06f658a46e3f2197f52d72d">new_buffer</a> (size_t size, const ::vk::BufferUsageFlags &amp;usage, const ::vk::MemoryPropertyFlags &amp;flags)</td></tr>
<tr class="memdesc:a6415277ee06f658a46e3f2197f52d72d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct and retrieve a new <a class="el" href="../../d6/d0a/classhp_1_1vk_1_1generic__buffer.html" title="Offers nice wrapper around functionality of vk::Buffer (See Vulkan documentation)">generic_buffer</a>.  <a href="../../dd/d17/classhp_1_1vk_1_1window.html#a6415277ee06f658a46e3f2197f52d72d">More...</a><br /></td></tr>
<tr class="separator:a6415277ee06f658a46e3f2197f52d72d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d650c3959dc947637110f2ebb5b2689"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#a9d650c3959dc947637110f2ebb5b2689">delete_buffer</a> (<a class="el" href="../../d6/d0a/classhp_1_1vk_1_1generic__buffer.html">generic_buffer</a> *buf)</td></tr>
<tr class="memdesc:a9d650c3959dc947637110f2ebb5b2689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a <a class="el" href="../../d6/d0a/classhp_1_1vk_1_1generic__buffer.html" title="Offers nice wrapper around functionality of vk::Buffer (See Vulkan documentation)">generic_buffer</a> associated with this window.  <a href="../../dd/d17/classhp_1_1vk_1_1window.html#a9d650c3959dc947637110f2ebb5b2689">More...</a><br /></td></tr>
<tr class="separator:a9d650c3959dc947637110f2ebb5b2689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2776b0cbd1678b9a395b28724501ee27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#a2776b0cbd1678b9a395b28724501ee27">draw_frame</a> ()</td></tr>
<tr class="memdesc:a2776b0cbd1678b9a395b28724501ee27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw the next frame to the screen.  <a href="../../dd/d17/classhp_1_1vk_1_1window.html#a2776b0cbd1678b9a395b28724501ee27">More...</a><br /></td></tr>
<tr class="separator:a2776b0cbd1678b9a395b28724501ee27"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a305cb8478e7b7488a0d45898e8cdb0a2"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#a305cb8478e7b7488a0d45898e8cdb0a2">shader_program</a></td></tr>
<tr class="separator:a305cb8478e7b7488a0d45898e8cdb0a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83fc33f12135a37af6a6a5bd964bf294"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#a83fc33f12135a37af6a6a5bd964bf294">generic_buffer</a></td></tr>
<tr class="separator:a83fc33f12135a37af6a6a5bd964bf294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c036901d113d3fa4314fcc7317646c"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#a80c036901d113d3fa4314fcc7317646c">vertex_buffer</a></td></tr>
<tr class="separator:a80c036901d113d3fa4314fcc7317646c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d18ecba703a792316f06cf9e9b3983"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#a51d18ecba703a792316f06cf9e9b3983">staging_buffer</a></td></tr>
<tr class="separator:a51d18ecba703a792316f06cf9e9b3983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af385227800848bafc2f3d59f06ea9027"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#af385227800848bafc2f3d59f06ea9027">on_resize_event</a> (GLFWwindow *win, int width, int height)</td></tr>
<tr class="separator:af385227800848bafc2f3d59f06ea9027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14074204cdf74522a5485742a7473318"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#a14074204cdf74522a5485742a7473318">on_iconify_event</a> (GLFWwindow *win, int state)</td></tr>
<tr class="separator:a14074204cdf74522a5485742a7473318"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Describes a vulkan window. Is used as a base for all operations. </p>

<p class="definition">Definition at line <a class="el" href="../../d2/d5a/window_8hpp_source.html#l00508">508</a> of file <a class="el" href="../../d2/d5a/window_8hpp_source.html">window.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2644434374ae6f8b89831c7580e84485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2644434374ae6f8b89831c7580e84485">&#9670;&nbsp;</a></span>window() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hp::vk::window::window </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Standard default constructor. </p>

</div>
</div>
<a id="a66f843075e00dd94c871a7123e8832ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66f843075e00dd94c871a7123e8832ec">&#9670;&nbsp;</a></span>window() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hp::vk::window::window </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>app_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Window constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>Width of the window in pixels </td></tr>
    <tr><td class="paramname">height</td><td>Height of the window in pixels </td></tr>
    <tr><td class="paramname">app_name</td><td>The name of you application </td></tr>
    <tr><td class="paramname">version</td><td>Version of you application, should be a return value of <code>VK_MAKE_VERSION()</code>. See vulkan documentation for more details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6cf6c258a30ce482fc6d5867b53cca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6cf6c258a30ce482fc6d5867b53cca4">&#9670;&nbsp;</a></span>~window()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hp::vk::window::~window </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Standard virtual destructor. </p>

</div>
</div>
<a id="a662c8ef349c9a583355590e2d217238a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a662c8ef349c9a583355590e2d217238a">&#9670;&nbsp;</a></span>window() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hp::vk::window::window </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html">window</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted copy constructor. Use the move constructor instead. </p>
<dl class="section note"><dt>Note</dt><dd>The standard copy constructor is deleted. You <em>MUST</em> use the <code><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#ae33053d857eb24d1752ba5d53c4e7d79" title="Standard copy constructor.">window(window &amp;&amp;other)</a> noexcept</code> move constructor instead! </dd></dl>

</div>
</div>
<a id="ae33053d857eb24d1752ba5d53c4e7d79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae33053d857eb24d1752ba5d53c4e7d79">&#9670;&nbsp;</a></span>window() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hp::vk::window::window </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html">window</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Standard copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Right hand side of the copy construction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1717af3841efc5694069541010d42c35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1717af3841efc5694069541010d42c35">&#9670;&nbsp;</a></span>clear_recording()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hp::vk::window::clear_recording </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the recording buffer. </p>

</div>
</div>
<a id="aa72a176c0c12f8a19a912e22872bcd0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa72a176c0c12f8a19a912e22872bcd0b">&#9670;&nbsp;</a></span>copy_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;::vk::Fence,::vk::CommandBuffer &gt; hp::vk::window::copy_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d6/d0a/classhp_1_1vk_1_1generic__buffer.html">generic_buffer</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/d0a/classhp_1_1vk_1_1generic__buffer.html">generic_buffer</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>wait</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>src_offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dest_offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy data from one buffer to another. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#a249fbf64d20a1b873899d967149a10dc" title="Destroy a fence associated with this window.">window::delete_fence</a> <a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#a5058be06596795644634e8a924897b3b" title="Destroy any command buffer associated with this window allocated to the current cmd_pool">window::delete_cmd_buffers</a> <a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#abd6dabdc499807c314ea44a40727c6f2" title="Block until the fences provided are signaled.">window::wait_fences</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source buffer of the copy operation </td></tr>
    <tr><td class="paramname">dest</td><td>The destination buffer of the copy operation </td></tr>
    <tr><td class="paramname">wait</td><td>Whether or not to wait for the copy operation to finish. See the return values for the function. </td></tr>
    <tr><td class="paramname">src_offset</td><td>Index (in bytes) in the source at which to start copying data. </td></tr>
    <tr><td class="paramname">dest_offset</td><td>Index (in bytes) in the destination at which to start writing data. </td></tr>
    <tr><td class="paramname">size</td><td>The size (in bytes) of the data that should be copied. If set to 0, the entire sizes of the buffers are automatically copied (ie. size is set to the size of the buffers, so the sizes <em>MUST</em> be equal) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a vk::Fence and vk::CommandBuffer if the <code>wait</code> parameter is set to <code>false</code>. These objects <em>MUST</em> be <em>EXPLICITLY DESTROYED!</em> If <code>wait</code> is <code>false</code> or the sizes of the buffers are mismatched while <code>size</code> is 0, then this function would return <code>VK_NULL_HANDLE</code>s. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is possible that the fence would never be signaled if the operation fails, so waiting for them may cause infinite blocking. Therefore, it is recommended that you set a timeout for fence waits. </dd></dl>

</div>
</div>
<a id="a9d650c3959dc947637110f2ebb5b2689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d650c3959dc947637110f2ebb5b2689">&#9670;&nbsp;</a></span>delete_buffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hp::vk::window::delete_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d6/d0a/classhp_1_1vk_1_1generic__buffer.html">generic_buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy a <a class="el" href="../../d6/d0a/classhp_1_1vk_1_1generic__buffer.html" title="Offers nice wrapper around functionality of vk::Buffer (See Vulkan documentation)">generic_buffer</a> associated with this window. </p>
<dl class="section note"><dt>Note</dt><dd>The supplied <a class="el" href="../../d6/d0a/classhp_1_1vk_1_1generic__buffer.html" title="Offers nice wrapper around functionality of vk::Buffer (See Vulkan documentation)">generic_buffer</a> <em>DOES NOT</em> have to be associate with this window, and it <em>DOES NOT</em> have to be created by <code><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#a6415277ee06f658a46e3f2197f52d72d" title="Construct and retrieve a new generic_buffer.">window::new_buffer</a></code>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The buffer to destroy </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d2/d5a/window_8hpp_source.html#l00966">966</a> of file <a class="el" href="../../d2/d5a/window_8hpp_source.html">window.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00966"></a><span class="lineno">  966</span>&#160;                                                       {</div>
<div class="line"><a name="l00967"></a><span class="lineno">  967</span>&#160;            boost::remove_erase(child_bufs, buf);</div>
<div class="line"><a name="l00968"></a><span class="lineno">  968</span>&#160;            <span class="keyword">delete</span> buf;</div>
<div class="line"><a name="l00969"></a><span class="lineno">  969</span>&#160;        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5058be06596795644634e8a924897b3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5058be06596795644634e8a924897b3b">&#9670;&nbsp;</a></span>delete_cmd_buffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hp::vk::window::delete_cmd_buffers </td>
          <td>(</td>
          <td class="paramtype">::vk::CommandBuffer *&#160;</td>
          <td class="paramname"><em>bufs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy any command buffer associated with this window allocated to the current <code>cmd_pool</code> </p>
<dl class="section note"><dt>Note</dt><dd>The command buffers supplied to this function <em>MUST</em> be associated with the current window and command pool! As of right now, the command pool is <em>NEVER</em> recreated. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufs</td><td>Pointer to a list of command buffers to destroy </td></tr>
    <tr><td class="paramname">num</td><td>Number of command buffers the list contains </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d2/d5a/window_8hpp_source.html#l00892">892</a> of file <a class="el" href="../../d2/d5a/window_8hpp_source.html">window.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00892"></a><span class="lineno">  892</span>&#160;                                                                                {</div>
<div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;            log_dev.freeCommandBuffers(cmd_pool, num, bufs);</div>
<div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a249fbf64d20a1b873899d967149a10dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a249fbf64d20a1b873899d967149a10dc">&#9670;&nbsp;</a></span>delete_fence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hp::vk::window::delete_fence </td>
          <td>(</td>
          <td class="paramtype">::vk::Fence&#160;</td>
          <td class="paramname"><em>fence</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy a fence associated with this window. </p>
<dl class="section note"><dt>Note</dt><dd>The fence provided <em>MUST</em> be associated with this window, but it <em>DOES NOT</em> have to be created with <code><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#aea8e50ae3bd4eb6d91deb2bc9bb06fb3" title="Construct and retrieve a new vk::Fence. See vulkan documentation for more details.">window::new_fence()</a></code>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fence</td><td>Fence to destroy </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d2/d5a/window_8hpp_source.html#l00937">937</a> of file <a class="el" href="../../d2/d5a/window_8hpp_source.html">window.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00937"></a><span class="lineno">  937</span>&#160;                                                {</div>
<div class="line"><a name="l00938"></a><span class="lineno">  938</span>&#160;            log_dev.destroyFence(fence, <span class="keyword">nullptr</span>);</div>
<div class="line"><a name="l00939"></a><span class="lineno">  939</span>&#160;            boost::remove_erase(child_fences, fence);</div>
<div class="line"><a name="l00940"></a><span class="lineno">  940</span>&#160;        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8065ba588e52c870c41e718d309ec78d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8065ba588e52c870c41e718d309ec78d">&#9670;&nbsp;</a></span>delete_shader_program()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hp::vk::window::delete_shader_program </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d92/classhp_1_1vk_1_1shader__program.html">shader_program</a> *&#160;</td>
          <td class="paramname"><em>sh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy a <a class="el" href="../../d0/d92/classhp_1_1vk_1_1shader__program.html" title="An abstraction of graphics pipelines (aka vk::Pipeline objects). See hp::vk::window::new_shader_progr...">shader_program</a> associated with this window. </p>
<dl class="section note"><dt>Note</dt><dd>The supplied <a class="el" href="../../d0/d92/classhp_1_1vk_1_1shader__program.html" title="An abstraction of graphics pipelines (aka vk::Pipeline objects). See hp::vk::window::new_shader_progr...">shader_program</a> <em>DOES NOT</em> have to be associate with this window, and it <em>DOES NOT</em> have to be created by <code><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#a5ca9e8ae513e459b6fb0b6111b35624f" title="Construct and retrieve a new hp::vk::shader_program">window::new_shader_program</a></code>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sh</td><td>Pointer to the shader program to destroy </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d2/d5a/window_8hpp_source.html#l00879">879</a> of file <a class="el" href="../../d2/d5a/window_8hpp_source.html">window.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;                                                              {</div>
<div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;            boost::remove_erase(child_shaders, sh);</div>
<div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;            <span class="keyword">delete</span> sh;</div>
<div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160;        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="af7021dcc20c2920b0a10daf40494ae61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7021dcc20c2920b0a10daf40494ae61">&#9670;&nbsp;</a></span>dev_ext_supported()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hp::vk::window::dev_ext_supported </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query if an extension is supported by the current physical device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ext</td><td>Name of the extension to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the extension is supported, otherwise false. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d2/d5a/window_8hpp_source.html#l00664">664</a> of file <a class="el" href="../../d2/d5a/window_8hpp_source.html">window.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;                                                       {</div>
<div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;            <span class="keywordflow">return</span> std::any_of(phys_dev_ext.begin(), phys_dev_ext.end(), __hp_vk_is_in_extension_prop_list(ext));</div>
<div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;        };</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2776b0cbd1678b9a395b28724501ee27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2776b0cbd1678b9a395b28724501ee27">&#9670;&nbsp;</a></span>draw_frame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hp::vk::window::draw_frame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw the next frame to the screen. </p>
<dl class="section note"><dt>Note</dt><dd>This function blocks until the frame is acquired, but <em>DOES NOT</em> block until it is presented. This function is also thread safe! :) </dd></dl>

</div>
</div>
<a id="a3fbc1a441b349b504876a368913edc0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fbc1a441b349b504876a368913edc0f">&#9670;&nbsp;</a></span>ext_supported()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hp::vk::window::ext_supported </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query if an extension is supported by the current instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ext</td><td>Name of the extension to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if extension is supported, otherwise false. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d2/d5a/window_8hpp_source.html#l00654">654</a> of file <a class="el" href="../../d2/d5a/window_8hpp_source.html">window.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;                                                   {</div>
<div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;            <span class="keywordflow">return</span> std::any_of(supported_ext.begin(), supported_ext.end(), __hp_vk_is_in_extension_prop_list(ext));</div>
<div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;        };</div>
</div><!-- fragment -->
</div>
</div>
<a id="a056dc1c6e863cbc75da8b18b8f468a8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a056dc1c6e863cbc75da8b18b8f468a8f">&#9670;&nbsp;</a></span>get_dims()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vk::Extent2D hp::vk::window::get_dims </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current size of the window (in pixels). </p>
<dl class="section return"><dt>Returns</dt><dd>The vulkan <code>Extent2D</code> assiciated with this window. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d2/d5a/window_8hpp_source.html#l00693">693</a> of file <a class="el" href="../../d2/d5a/window_8hpp_source.html">window.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;                                     {</div>
<div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;            <span class="keywordflow">return</span> swap_extent;</div>
<div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3bc875261858f4bdb4815963733327e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bc875261858f4bdb4815963733327e5">&#9670;&nbsp;</a></span>layer_supported()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hp::vk::window::layer_supported </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>lay</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a validation layer is supported by the current instance. </p>
<dl class="section note"><dt>Note</dt><dd>Disabling validation layers <em>WILL NOT</em> affect the behavior of this function. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lay</td><td>The name of the validation layer to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the validation layer is supported, otherwise false. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d2/d5a/window_8hpp_source.html#l00675">675</a> of file <a class="el" href="../../d2/d5a/window_8hpp_source.html">window.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;                                                     {</div>
<div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;            <span class="keywordflow">return</span> std::any_of(supported_lay.begin(), supported_lay.end(), __hp_vk_is_in_layer_prop_list(lay));</div>
<div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;        };</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6415277ee06f658a46e3f2197f52d72d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6415277ee06f658a46e3f2197f52d72d">&#9670;&nbsp;</a></span>new_buffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d0a/classhp_1_1vk_1_1generic__buffer.html">generic_buffer</a> * hp::vk::window::new_buffer </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::vk::BufferUsageFlags &amp;&#160;</td>
          <td class="paramname"><em>usage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::vk::MemoryPropertyFlags &amp;&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct and retrieve a new <a class="el" href="../../d6/d0a/classhp_1_1vk_1_1generic__buffer.html" title="Offers nice wrapper around functionality of vk::Buffer (See Vulkan documentation)">generic_buffer</a>. </p>
<dl class="section warning"><dt>Warning</dt><dd>DO NOT attempt to call <code>delete</code> on pointer returned by this function! Use <code><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#a9d650c3959dc947637110f2ebb5b2689" title="Destroy a generic_buffer associated with this window.">window::delete_buffer()</a></code> instead! It is also <em>NOT</em> necessary to call <code>delete_buffer</code>; the buffers are automatically cleaned up when window is destroyed! </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size (in bytes) of the buffer to create. </td></tr>
    <tr><td class="paramname">usage</td><td>See <code><a class="el" href="../../da/d74/namespacehp_1_1vk.html#a64cad9193e2851bb7e28a7cc88e18f62" title="Vulkan buffer usage flag specifying the buffer for usage as a vertex_buffer (VBO) written to using a ...">hp::vk::vertex_usage</a></code>, <code><a class="el" href="../../da/d74/namespacehp_1_1vk.html#a783fbe005f3fb9a5d505f21a6de04f14" title="Vulkan buffer usage flag specifying the buffer for usage as a index buffer (IBO) written to using a s...">hp::vk::index_usage</a></code>, etc. Consult Vulkan docs for vk::BufferUsageFlags. </td></tr>
    <tr><td class="paramname">flags</td><td>See <code><a class="el" href="../../da/d74/namespacehp_1_1vk.html#a0ed92317b324570e8260cc42c93ddc80" title="Vulkan memory property flag specifying that memory should be allocated in a place quickly accessible ...">hp::vk::memory_local</a></code> and <code><a class="el" href="../../da/d74/namespacehp_1_1vk.html#a1c3b08561cbe2378f706461045728ffa" title="Vulkan memory property flag specifying that memory should be allocated in a place that is synchronize...">hp::vk::memory_host</a></code>. Consult Vulkan docs for vk::MemoryPropertyFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the newly constructed buffer. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d2/d5a/window_8hpp_source.html#l00953">953</a> of file <a class="el" href="../../d2/d5a/window_8hpp_source.html">window.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00953"></a><span class="lineno">  953</span>&#160;                                                                                                     {</div>
<div class="line"><a name="l00954"></a><span class="lineno">  954</span>&#160;            <span class="keyword">auto</span> buf = <span class="keyword">new</span> <a class="code" href="../../dd/d17/classhp_1_1vk_1_1window.html#a83fc33f12135a37af6a6a5bd964bf294">generic_buffer</a>(size, usage, flags, <span class="keyword">this</span>);</div>
<div class="line"><a name="l00955"></a><span class="lineno">  955</span>&#160;            child_bufs.emplace_back(buf);</div>
<div class="line"><a name="l00956"></a><span class="lineno">  956</span>&#160;            <span class="keywordflow">return</span> buf;</div>
<div class="line"><a name="l00957"></a><span class="lineno">  957</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="../../d2/d5a/window_8hpp_source.html#l00584">generic_buffer</a>.</p>

</div>
</div>
<a id="aea8e50ae3bd4eb6d91deb2bc9bb06fb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea8e50ae3bd4eb6d91deb2bc9bb06fb3">&#9670;&nbsp;</a></span>new_fence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vk::Fence hp::vk::window::new_fence </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct and retrieve a new vk::Fence. See vulkan documentation for more details. </p>
<dl class="section warning"><dt>Warning</dt><dd>DO NOT attempt to call <code>delete</code> on pointer returned by this function! Use <code><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#a249fbf64d20a1b873899d967149a10dc" title="Destroy a fence associated with this window.">window::delete_fence()</a></code> instead! It is also <em>NOT</em> necessary to call <code>delete_fence</code>; the fences are automatically cleaned up when window is destroyed! </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The newly constructed vk::Fence </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d2/d5a/window_8hpp_source.html#l00920">920</a> of file <a class="el" href="../../d2/d5a/window_8hpp_source.html">window.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160;                                   {</div>
<div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;            ::vk::Fence ret = ::vk::Fence();</div>
<div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;            ::vk::FenceCreateInfo fence_ci((::vk::FenceCreateFlags()));</div>
<div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;            <span class="keywordflow">if</span> (<a class="code" href="../../da/d74/namespacehp_1_1vk.html#aa7195ccef9de54ede16edbd813342934">handle_res</a>(log_dev.createFence(&amp;fence_ci, <span class="keyword">nullptr</span>, &amp;ret), <a class="code" href="../../d0/da9/logging_8hpp.html#a7f4242cf6cd929a580518c160aebc8fb">HP_GET_CODE_LOC</a>) != ::vk::Result::eSuccess) {</div>
<div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;                HP_FATAL(<span class="stringliteral">&quot;Failed to create fences!&quot;</span>);</div>
<div class="line"><a name="l00925"></a><span class="lineno">  925</span>&#160;            }</div>
<div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;            child_fences.emplace_back(ret);</div>
<div class="line"><a name="l00927"></a><span class="lineno">  927</span>&#160;            <span class="keywordflow">return</span> ret;</div>
<div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160;        }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="../../da/d74/namespacehp_1_1vk.html#aa7195ccef9de54ede16edbd813342934">hp::vk::handle_res()</a>, and <a class="el" href="../../d0/da9/logging_8hpp_source.html#l00106">HP_GET_CODE_LOC</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../dd/d17/classhp_1_1vk_1_1window_aea8e50ae3bd4eb6d91deb2bc9bb06fb3_cgraph.png" border="0" usemap="#dd/d17/classhp_1_1vk_1_1window_aea8e50ae3bd4eb6d91deb2bc9bb06fb3_cgraph" alt=""/></div>
<map name="dd/d17/classhp_1_1vk_1_1window_aea8e50ae3bd4eb6d91deb2bc9bb06fb3_cgraph" id="dd/d17/classhp_1_1vk_1_1window_aea8e50ae3bd4eb6d91deb2bc9bb06fb3_cgraph">
<area shape="rect" title="Construct and retrieve a new vk::Fence. See vulkan documentation for more details." alt="" coords="5,5,146,44"/>
<area shape="rect" href="../../da/d74/namespacehp_1_1vk.html#aa7195ccef9de54ede16edbd813342934" title="Handle the results returned by vulkan functions, and log it if an error had occurred." alt="" coords="194,12,324,37"/>
</map>
</div>

</div>
</div>
<a id="a5ca9e8ae513e459b6fb0b6111b35624f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ca9e8ae513e459b6fb0b6111b35624f">&#9670;&nbsp;</a></span>new_shader_program()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d92/classhp_1_1vk_1_1shader__program.html">shader_program</a> * hp::vk::window::new_shader_program </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>metapath</em> = <code>&quot;/shader_metadat.txt&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct and retrieve a new <code><a class="el" href="../../d0/d92/classhp_1_1vk_1_1shader__program.html" title="An abstraction of graphics pipelines (aka vk::Pipeline objects). See hp::vk::window::new_shader_progr...">hp::vk::shader_program</a></code> </p>
<p>Upon construction, the file at <code>"fp + metapath"</code> will be loaded and read. The expected contents of each line of the file are: <code>"[fragment-shader|vertex-shader];[entrypoint]: [filename]"</code> (Example: <code>"vertex-shader;main: vert.spv"</code> would load <code>fp + "/vert.spv"</code> as the vertex shader with entrypoint "main"). Whitespace is ignored and comments are made with the <code>"#"</code> character. Comments at the end of lines are <em>NOT</em> supported. The line <code>"fragment-shader;main: frag.spv  # &lt;some comment&gt;"</code> would be invalid. Further examples are available under the "Examples" tag of the documentation.</p>
<dl class="section warning"><dt>Warning</dt><dd>DO NOT attempt to call <code>delete</code> on pointer returned by this function! Use <code><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#a8065ba588e52c870c41e718d309ec78d" title="Destroy a shader_program associated with this window.">window::delete_shader_program()</a></code> instead! It is also <em>NOT</em> necessary to call <code>delete_shader_program</code>; the shaders are automatically cleaned up when window is destroyed! </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>The path to load the shader program from. <em>DO NOT</em> INCLUDE A TRAILING SLASH OR THE LOADING OPERATION <em>WILL</em> FAIL </td></tr>
    <tr><td class="paramname">metapath</td><td>The path to the file containing the metadata for the shader. A LEADING SLASH <em>MUST</em> BE INCLUDED OR THE LOADING OPERATION <em>WILL</em> FAIL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly constructed <code><a class="el" href="../../d0/d92/classhp_1_1vk_1_1shader__program.html" title="An abstraction of graphics pipelines (aka vk::Pipeline objects). See hp::vk::window::new_shader_progr...">shader_program</a></code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d2/d5a/window_8hpp_source.html#l00866">866</a> of file <a class="el" href="../../d2/d5a/window_8hpp_source.html">window.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;                                                                                                                     {</div>
<div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;            <span class="keyword">auto</span> new_prog = <span class="keyword">new</span> <a class="code" href="../../dd/d17/classhp_1_1vk_1_1window.html#a305cb8478e7b7488a0d45898e8cdb0a2">shader_program</a>(fp, metapath, <span class="keyword">this</span>);</div>
<div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;            child_shaders.emplace_back(new_prog);</div>
<div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;            <span class="keywordflow">return</span> new_prog;</div>
<div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;        };</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="../../d2/d5a/window_8hpp_source.html#l00582">shader_program</a>.</p>

</div>
</div>
<a id="a10920ba0b45232900147bff04455df23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10920ba0b45232900147bff04455df23">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html">window</a> &amp; hp::vk::window::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html">window</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted copy assignment operator. Use the move assignment operator instead. </p>
<dl class="section note"><dt>Note</dt><dd>The standard copy assignment operator is deleted. You <em>MUST</em> use the <code>window &amp;<a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#ae4d21756ed28640247697cde8714e022" title="Standard move assignment operator.">operator=(window &amp;&amp;other)</a> noexcept</code> move assignment operator instead. </dd></dl>

</div>
</div>
<a id="ae4d21756ed28640247697cde8714e022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4d21756ed28640247697cde8714e022">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html">window</a> &amp; hp::vk::window::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html">window</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Standard move assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Right hand side of the move assignment operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Forwards the <code>other</code> parameter. </dd></dl>

</div>
</div>
<a id="a00141a7a44204dddc48ef529f41a0459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00141a7a44204dddc48ef529f41a0459">&#9670;&nbsp;</a></span>rec_bind_index_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hp::vk::window::rec_bind_index_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d2/d99/structhp_1_1vk_1_1index__buffer.html">index_buffer</a>&#160;</td>
          <td class="paramname"><em>ibo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record binding an index buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ibo</td><td>Index buffer to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7bd0d8d5fa09d80bf61f1309bbbbe144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bd0d8d5fa09d80bf61f1309bbbbe144">&#9670;&nbsp;</a></span>rec_bind_shader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hp::vk::window::rec_bind_shader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d92/classhp_1_1vk_1_1shader__program.html">shader_program</a> *&#160;</td>
          <td class="paramname"><em>shader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a pipeline binding operation to the recording buffer. </p>
<p>Call this function before setting viewports, scissors, and other dynamic states. A pipeline must be bound for <em>ANY</em> draw operation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shader</td><td>Shader to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1673d156a395348eb49f8ffb3af56bfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1673d156a395348eb49f8ffb3af56bfe">&#9670;&nbsp;</a></span>rec_bind_vbo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hp::vk::window::rec_bind_vbo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/d19/structhp_1_1vk_1_1vertex__buffer.html">vertex_buffer</a>&#160;</td>
          <td class="paramname"><em>vbo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record binding a vertex buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vbo</td><td>VBO to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f7cf0a4354f54666976981b179b4294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f7cf0a4354f54666976981b179b4294">&#9670;&nbsp;</a></span>rec_draw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hp::vk::window::rec_draw </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num_verts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record issuing a standard draw command. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_verts</td><td>Number of vertices to draw. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38bdd83da7bcc03e0337505f0a2a8829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38bdd83da7bcc03e0337505f0a2a8829">&#9670;&nbsp;</a></span>rec_draw_indexed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hp::vk::window::rec_draw_indexed </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_indices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record issuing a draw command using the index buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_indices</td><td>Number of indices from the index buffer to draw. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a904e80624e2028229a320a674626abb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a904e80624e2028229a320a674626abb5">&#9670;&nbsp;</a></span>rec_set_default_scissor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hp::vk::window::rec_set_default_scissor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record setting the default scissor, which covers the entire screen. </p>

</div>
</div>
<a id="a6ffec5451f68d4a2eaa973310743717d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ffec5451f68d4a2eaa973310743717d">&#9670;&nbsp;</a></span>rec_set_default_viewport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hp::vk::window::rec_set_default_viewport </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record setting the default viewport, which covers the entire screen. </p>

</div>
</div>
<a id="aedd05d260b2d9c0ed537b899b2a4d755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedd05d260b2d9c0ed537b899b2a4d755">&#9670;&nbsp;</a></span>rec_set_scissor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hp::vk::window::rec_set_scissor </td>
          <td>(</td>
          <td class="paramtype">::vk::Rect2D&#160;</td>
          <td class="paramname"><em>scissor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record setting the scissor. Consult vulkan docs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scissor</td><td>New scissor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9803e6ae8daa92d634b277712c12cc24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9803e6ae8daa92d634b277712c12cc24">&#9670;&nbsp;</a></span>rec_set_viewport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hp::vk::window::rec_set_viewport </td>
          <td>(</td>
          <td class="paramtype">::vk::Viewport&#160;</td>
          <td class="paramname"><em>viewport</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record setting the viewport. Consult vulkan docs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">viewport</td><td>New viewport </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="accf9acdf9dca93ec205add02b07debbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accf9acdf9dca93ec205add02b07debbe">&#9670;&nbsp;</a></span>save_recording()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hp::vk::window::save_recording </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create new command buffers according to the contents of the recording buffer. </p>

</div>
</div>
<a id="a887c3c901c8e64840d36b65ceb989de4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a887c3c901c8e64840d36b65ceb989de4">&#9670;&nbsp;</a></span>set_swap_recreate_callback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hp::vk::window::set_swap_recreate_callback </td>
          <td>(</td>
          <td class="paramtype">void(*)(::vk::Extent2D)&#160;</td>
          <td class="paramname"><em>new_callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the callback that is called whenever the swapchain needs to be recreated. </p>
<p>Use this callback to re-record the command buffers if you wish. (The viewport and scissor would've changed, so rerecording would be necessary) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_callback</td><td>The new callback to replace the old one. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>DO NOT CALL <code><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#accf9acdf9dca93ec205add02b07debbe" title="Create new command buffers according to the contents of the recording buffer.">save_recording()</a></code> IN THE CALLBACK! SWAP CHAIN RECREATION ALREADY IMPLICITLY CALLS IT! </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d2/d5a/window_8hpp_source.html#l00771">771</a> of file <a class="el" href="../../d2/d5a/window_8hpp_source.html">window.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;                                                                                {</div>
<div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;            swap_recreate_callback = new_callback;</div>
<div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aba36c9e984ffc59fd802bf7973960ce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba36c9e984ffc59fd802bf7973960ce1">&#9670;&nbsp;</a></span>should_close()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hp::vk::window::should_close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Poll if this window should be closed (ie. The user closed it) </p>
<dl class="section return"><dt>Returns</dt><dd>True if the window should close (ie. You should terminate the program, or other appropriate behavior) </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d2/d5a/window_8hpp_source.html#l00684">684</a> of file <a class="el" href="../../d2/d5a/window_8hpp_source.html">window.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;                                   {</div>
<div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;            <span class="keywordflow">return</span> glfwWindowShouldClose(win);</div>
<div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;        };</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4a2ec279762d0dc85f2382dd4337ee1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a2ec279762d0dc85f2382dd4337ee1e">&#9670;&nbsp;</a></span>start_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t * hp::vk::window::start_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d6/d0a/classhp_1_1vk_1_1generic__buffer.html">generic_buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map a buffer so it is ready for writing. </p>
<dl class="section warning"><dt>Warning</dt><dd>Mapped memory <em>IS NOT</em> automatically unmapped! Any call to <code><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#a4a2ec279762d0dc85f2382dd4337ee1e" title="Map a buffer so it is ready for writing.">start_write()</a></code> <em>MUST</em> be accompanied by a call to <code><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#a650ae8a55d1b43a4e948217c38abd388" title="Unmap a buffer so it is ready for reading and use.">stop_write()</a></code> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Buffer to map </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the mapped region </dd></dl>

</div>
</div>
<a id="a650ae8a55d1b43a4e948217c38abd388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a650ae8a55d1b43a4e948217c38abd388">&#9670;&nbsp;</a></span>stop_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hp::vk::window::stop_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d6/d0a/classhp_1_1vk_1_1generic__buffer.html">generic_buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unmap a buffer so it is ready for reading and use. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Buffer to unmap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd6dabdc499807c314ea44a40727c6f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd6dabdc499807c314ea44a40727c6f2">&#9670;&nbsp;</a></span>wait_fences()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hp::vk::window::wait_fences </td>
          <td>(</td>
          <td class="paramtype">::vk::Fence *&#160;</td>
          <td class="paramname"><em>fences</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>UINT64_MAX</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Block until the fences provided are signaled. </p>
<dl class="section note"><dt>Note</dt><dd>The fence provided <em>MUST</em> be associated with this window! </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fences</td><td>Pointer to a list of fences </td></tr>
    <tr><td class="paramname">num</td><td>The number of fences that list contains (default to 1 for waiting on a single fence) </td></tr>
    <tr><td class="paramname">timeout</td><td>The maximum amount of time (in nanoseconds) this would block before aborting. By default there is no timeout (Signified by the value <code>UINT64_MAX</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>If no timeout is set, this function would block forever if the fence is never signaled, which <em>CAN</em> happen! Therefore, it is recommended to define a timeout. Do not set it too low, or the operation wouldn't have a change to complete. Don't set it too high, or the application would be forced to wait that number of nanoseconds if the fence is never signaled. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d2/d5a/window_8hpp_source.html#l00909">909</a> of file <a class="el" href="../../d2/d5a/window_8hpp_source.html">window.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;                                                                                                  {</div>
<div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;            log_dev.waitForFences(num, fences, ::vk::Bool32(VK_TRUE), timeout);</div>
<div class="line"><a name="l00911"></a><span class="lineno">  911</span>&#160;        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a17536da75810d265a3f480d2ad37a2b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17536da75810d265a3f480d2ad37a2b1">&#9670;&nbsp;</a></span>write_buffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hp::vk::window::write_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d6/d0a/classhp_1_1vk_1_1generic__buffer.html">generic_buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data to a buffer with <code>eHostCoherent</code> and <code>eHostVisible</code>. </p>
<p>This function maps and unmaps the buffer. See <code>void write_buffer(uint8_t *dest, <a class="el" href="../../d6/d0a/classhp_1_1vk_1_1generic__buffer.html" title="Offers nice wrapper around functionality of vk::Buffer (See Vulkan documentation)">generic_buffer</a> *buf, const void *src, size_t offset = 0, size_t size = 0)</code>, <code><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#a4a2ec279762d0dc85f2382dd4337ee1e" title="Map a buffer so it is ready for writing.">window::start_write()</a></code>, and <code><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#a650ae8a55d1b43a4e948217c38abd388" title="Unmap a buffer so it is ready for reading and use.">window::stop_write()</a></code> for explicit mapping/unmapping. </p><dl class="section note"><dt>Note</dt><dd>The supplied buffer <em>MUST</em> have the memory property <code>eHostVisible</code> and <code>eHostCoherent</code>! Consult vulkan docs. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The buffer to write to. </td></tr>
    <tr><td class="paramname">data</td><td>The data to write </td></tr>
    <tr><td class="paramname">offset</td><td>The index (in bytes) of the buffer at which to start writing. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the data to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f4a25b2c0e0d68389d8d286404fbebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f4a25b2c0e0d68389d8d286404fbebc">&#9670;&nbsp;</a></span>write_buffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hp::vk::window::write_buffer </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/d0a/classhp_1_1vk_1_1generic__buffer.html">generic_buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data to a buffer with <code>eHostCoherent</code> and <code>eHostVisible</code>. </p>
<p>This function <em>DOES NOT</em> map and unmap memory! Memory must be explicitly mapped/unmapped using <code><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#a4a2ec279762d0dc85f2382dd4337ee1e" title="Map a buffer so it is ready for writing.">start_write()</a></code> and <code><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#a650ae8a55d1b43a4e948217c38abd388" title="Unmap a buffer so it is ready for reading and use.">stop_write()</a></code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The data to write to. Should be the value returned from <code><a class="el" href="../../dd/d17/classhp_1_1vk_1_1window.html#a4a2ec279762d0dc85f2382dd4337ee1e" title="Map a buffer so it is ready for writing.">hp::vk::window::start_write()</a></code> </td></tr>
    <tr><td class="paramname">buf</td><td>The buffer to write to. </td></tr>
    <tr><td class="paramname">src</td><td>The data to write. </td></tr>
    <tr><td class="paramname">offset</td><td>The index (in bytes) at which to start writing. </td></tr>
    <tr><td class="paramname">size</td><td>Size of the data to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a83fc33f12135a37af6a6a5bd964bf294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83fc33f12135a37af6a6a5bd964bf294">&#9670;&nbsp;</a></span>generic_buffer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="../../d6/d0a/classhp_1_1vk_1_1generic__buffer.html">generic_buffer</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d2/d5a/window_8hpp_source.html#l00584">584</a> of file <a class="el" href="../../d2/d5a/window_8hpp_source.html">window.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d2/d5a/window_8hpp_source.html#l00953">new_buffer()</a>.</p>

</div>
</div>
<a id="a14074204cdf74522a5485742a7473318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14074204cdf74522a5485742a7473318">&#9670;&nbsp;</a></span>on_iconify_event</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void on_iconify_event </td>
          <td>(</td>
          <td class="paramtype">GLFWwindow *&#160;</td>
          <td class="paramname"><em>win</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af385227800848bafc2f3d59f06ea9027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af385227800848bafc2f3d59f06ea9027">&#9670;&nbsp;</a></span>on_resize_event</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void on_resize_event </td>
          <td>(</td>
          <td class="paramtype">GLFWwindow *&#160;</td>
          <td class="paramname"><em>win</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a305cb8478e7b7488a0d45898e8cdb0a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a305cb8478e7b7488a0d45898e8cdb0a2">&#9670;&nbsp;</a></span>shader_program</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="../../d0/d92/classhp_1_1vk_1_1shader__program.html">shader_program</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d2/d5a/window_8hpp_source.html#l00582">582</a> of file <a class="el" href="../../d2/d5a/window_8hpp_source.html">window.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d2/d5a/window_8hpp_source.html#l00866">new_shader_program()</a>.</p>

</div>
</div>
<a id="a51d18ecba703a792316f06cf9e9b3983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51d18ecba703a792316f06cf9e9b3983">&#9670;&nbsp;</a></span>staging_buffer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class staging_buffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d2/d5a/window_8hpp_source.html#l00588">588</a> of file <a class="el" href="../../d2/d5a/window_8hpp_source.html">window.hpp</a>.</p>

</div>
</div>
<a id="a80c036901d113d3fa4314fcc7317646c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80c036901d113d3fa4314fcc7317646c">&#9670;&nbsp;</a></span>vertex_buffer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="../../df/d19/structhp_1_1vk_1_1vertex__buffer.html">vertex_buffer</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d2/d5a/window_8hpp_source.html#l00586">586</a> of file <a class="el" href="../../d2/d5a/window_8hpp_source.html">window.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/hp/vk/<a class="el" href="../../d2/d5a/window_8hpp_source.html">window.hpp</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="anamespacehp_1_1vk_html_aa7195ccef9de54ede16edbd813342934"><div class="ttname"><a href="../../da/d74/namespacehp_1_1vk.html#aa7195ccef9de54ede16edbd813342934">hp::vk::handle_res</a></div><div class="ttdeci">::vk::Result handle_res(::vk::Result res, hp::code_location loc)</div><div class="ttdoc">Handle the results returned by vulkan functions, and log it if an error had occurred.</div></div>
<div class="ttc" id="alogging_8hpp_html_a7f4242cf6cd929a580518c160aebc8fb"><div class="ttname"><a href="../../d0/da9/logging_8hpp.html#a7f4242cf6cd929a580518c160aebc8fb">HP_GET_CODE_LOC</a></div><div class="ttdeci">#define HP_GET_CODE_LOC</div><div class="ttdoc">Builds the appropriate hp::code_location struct for where it is invoked.</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/da9/logging_8hpp_source.html#l00106">logging.hpp:106</a></div></div>
<div class="ttc" id="aclasshp_1_1vk_1_1window_html_a305cb8478e7b7488a0d45898e8cdb0a2"><div class="ttname"><a href="../../dd/d17/classhp_1_1vk_1_1window.html#a305cb8478e7b7488a0d45898e8cdb0a2">hp::vk::window::shader_program</a></div><div class="ttdeci">friend class shader_program</div><div class="ttdef"><b>Definition:</b> <a href="../../d2/d5a/window_8hpp_source.html#l00582">window.hpp:582</a></div></div>
<div class="ttc" id="aclasshp_1_1vk_1_1window_html_a83fc33f12135a37af6a6a5bd964bf294"><div class="ttname"><a href="../../dd/d17/classhp_1_1vk_1_1window.html#a83fc33f12135a37af6a6a5bd964bf294">hp::vk::window::generic_buffer</a></div><div class="ttdeci">friend class generic_buffer</div><div class="ttdef"><b>Definition:</b> <a href="../../d2/d5a/window_8hpp_source.html#l00584">window.hpp:584</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Nov 30 2019 19:33:25 for Hephaestus by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
